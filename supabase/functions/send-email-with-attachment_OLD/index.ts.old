/// <reference types="@supabase/supabase-js" />

// Setup type definitions for built-in Supabase Runtime APIs
// import "jsr:@supabase/functions-js/edge-runtime.d.ts";
// Polyfill Buffer for Node.js compatibility (needed by Nodemailer/crypto)
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
// Restore the correct esm.sh import path and SupabaseClient type for supabase-js
import { createClient, SupabaseClient } from "https://esm.sh/@supabase/supabase-js@2";
// Import Buffer using the Deno standard library path for Node compatibility
import { Buffer } from "https://deno.land/std@0.168.0/node/buffer.ts";
// Make Buffer globally available for dependencies that might expect it
(globalThis as any).Buffer = Buffer;

import { render } from "https://esm.sh/preact-render-to-string@6.2.0"; // Feste Version für HTML-Rendering
import { h } from "https://esm.sh/preact@10.18.1";
import ExcelJS from "https://esm.sh/exceljs@4.3.0";
import jsPDF from "https://esm.sh/jspdf@2.5.1";
import autoTable from "https://esm.sh/jspdf-autotable@3.7.0"; // Feste Version
import { encode } from "https://deno.land/std@0.168.0/encoding/base64.ts";

console.log("Function initializing...");

// Hilfsfunktion zum Escapen von HTML
const escapeHtml = (unsafe: string | number | null | undefined): string => {
  if (unsafe === null || unsafe === undefined) return '';
  const str = String(unsafe);
  return str
       .replace(/&/g, "&amp;")
       .replace(/</g, "&lt;")
       .replace(/>/g, "&gt;")
       .replace(/"/g, "&quot;")
       .replace(/'/g, "&#039;");
};

// CORS Headers
const corsHeaders = {
  "Access-Control-Allow-Origin": "*", // Passe dies für die Produktion an
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS", // OPTIONS hinzufügen
};

// Typdefinitionen (vereinfacht)
interface ReportEntry {
  date: string | null;
  description: string | null;
  hours: number | null;
  absences: number | null;
  overtime: number | null;
}

interface ReportData {
  name: string;
  period: string;
  entries: ReportEntry[];
  includeCompanyInfo?: boolean;
}

interface Attachment {
  filename: string;
  content: string; // Base64 encoded content
  contentType: string;
}

interface RequestPayload {
  to: string;
  subject: string;
  text: string;
  userId: string;
  attachment?: Attachment; // Attachment ist jetzt optional und enthält Base64-Daten
  reportData?: ReportData; // Optional: Reportdaten, falls generiert werden soll
  format?: 'excel' | 'pdf' | 'csv'; // Optional: Format für die Generierung
}

interface SmtpConfig {
  host: string;
  port: number;
  secure?: boolean; // Optional, wird in Vercel Function bestimmt
  auth: {
    user: string;
    pass: string;
  };
}

interface AttachmentData {
  filename: string;
  content: Uint8Array | ArrayBuffer; // Content generated by libraries
  contentType: string;
}

interface EmailRequestBody {
  to: string;
  subject: string;
  text?: string; // Optional text content
  html?: string; // Optional html content (generated from report)
  smtpConfig: SmtpConfig;
  reportData: WorkReportData; // Assuming report data is passed to generate attachment
  format: "excel" | "pdf" | "csv"; // Format for attachment generation
}

interface WorkReportData {
  client: string;
  month: string;
  year: string;
  totalHours: number;
  employeeName: string;
  entries: Array<{
    date: string;
    description: string;
    hours: number;
    location: string; // Added location field
  }>;
}

// Example: generateExcelAttachment (ensure it returns AttachmentData)
async function generateExcelAttachment(reportData: WorkReportData): Promise<AttachmentData> {
  const workbook = new ExcelJS.Workbook();
  const sheet = workbook.addWorksheet("Arbeitsrapport");

  // Add Header Row
  sheet.addRow([
    "Datum",
    "Arbeitsort", // Added header for location
    "Beschreibung der Arbeit",
    "Stunden",
  ]);

  // Add Data Rows
  reportData.entries.forEach((entry) => {
    sheet.addRow([
      entry.date,
      entry.location || "", // Use location or empty string
      entry.description,
      entry.hours,
    ]);
  });

  // Add Footer Row (Example)
  sheet.addRow([]); // Empty row for spacing
  sheet.addRow(["Gesamtstunden:", "", "", reportData.totalHours]);
  sheet.addRow(["Mitarbeiter:", reportData.employeeName]);
  sheet.addRow(["Kunde:", reportData.client]);
  sheet.addRow(["Monat/Jahr:", `${reportData.month}/${reportData.year}`]);


  // Auto-width columns based on content
  sheet.columns.forEach((column) => {
     let maxLength = 0;
     column.eachCell!({ includeEmpty: true }, (cell) => {
       let columnLength = cell.value ? cell.value.toString().length : 10;
       if (columnLength > maxLength) {
         maxLength = columnLength;
       }
     });
     column.width = maxLength < 10 ? 10 : maxLength + 1; // Set minimum width
   });


  const buffer = await workbook.xlsx.writeBuffer(); // Returns ArrayBuffer in Deno context? Check ExcelJS docs for Deno. Assuming ArrayBuffer.
  return {
    filename: `Arbeitsrapport_${reportData.client}_${reportData.month}_${reportData.year}.xlsx`,
    content: buffer, // Keep as ArrayBuffer/Uint8Array for Base64 encoding
    contentType:
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  };
}

// Example: generatePdfAttachment (ensure it returns AttachmentData)
async function generatePdfAttachment(reportData: WorkReportData): Promise<AttachmentData> {
  const doc = new jsPDF();
  const tableColumn = ["Datum", "Arbeitsort", "Beschreibung", "Stunden"]; // Added "Arbeitsort"
  const tableRows: (string | number)[][] = [];

  reportData.entries.forEach((entry) => {
    const rowData = [
      entry.date,
      entry.location || "", // Use location or empty string
      entry.description,
      entry.hours.toFixed(2),
    ];
    tableRows.push(rowData);
  });

  doc.setFontSize(18);
  doc.text(`Arbeitsrapport für ${reportData.client}`, 14, 20);
  doc.setFontSize(11);
  doc.text(`Mitarbeiter: ${reportData.employeeName}`, 14, 30);
  doc.text(`Monat/Jahr: ${reportData.month}/${reportData.year}`, 14, 36);

  // Use autoTable plugin
  autoTable(doc, {
    startY: 45,
    head: [tableColumn],
    body: tableRows,
    theme: 'grid',
    headStyles: { fillColor: [22, 160, 133] }, // Example header color
    didDrawPage: (data) => {
        // Optional: Footer on each page
        doc.setFontSize(9);
        doc.text('Seite ' + doc.internal.getNumberOfPages(), data.settings.margin.left, doc.internal.pageSize.height - 10);
    }
  });

  // Add total hours after the table
  const finalY = (doc as any).lastAutoTable.finalY || 50; // Get Y position after table
  doc.setFontSize(11);
  doc.text(`Gesamtstunden: ${reportData.totalHours.toFixed(2)}`, 14, finalY + 10);


  const buffer = doc.output("arraybuffer"); // Returns ArrayBuffer
  return {
    filename: `Arbeitsrapport_${reportData.client}_${reportData.month}_${reportData.year}.pdf`,
    content: buffer,
    contentType: "application/pdf",
  };
}

// Diese Funktion verarbeitet ausschließlich JSON!
serve(async (req: Request) => {
  console.log(`[${new Date().toISOString()}] Received request: ${req.method} ${req.url}`);

  // CORS preflight request handling
  if (req.method === "OPTIONS") {
    console.log(`[${new Date().toISOString()}] Handling OPTIONS request`);
    return new Response("ok", { headers: corsHeaders });
  }

  // Ensure it's a POST request
  if (req.method !== "POST") {
    console.error(`[${new Date().toISOString()}] Invalid method: ${req.method}`);
    return new Response(JSON.stringify({ error: "Method Not Allowed" }), {
      status: 405,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }

  // Check Content-Type header
  const contentType = req.headers.get('Content-Type');
  console.log(`[${new Date().toISOString()}] Content-Type: ${contentType}`);
  if (contentType !== 'application/json') {
    console.error(`[${new Date().toISOString()}] Invalid Content-Type: ${contentType}`);
    return new Response(
      JSON.stringify({ error: "Content-Type must be 'application/json'" }),
      {
        status: 415, // Use 415 Unsupported Media Type
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }

  let payload: EmailRequestBody;
  try {
    console.log(`[${new Date().toISOString()}] Parsing request body...`);
    payload = await req.json();
    console.log(`[${new Date().toISOString()}] Request body parsed successfully.`);
    // Log payload details safely (avoid logging full attachment content)
    console.log(`[${new Date().toISOString()}] Payload details: to=${payload.to}, subject=${payload.subject}, smtpConfig=${JSON.stringify(payload.smtpConfig)}`);
  } catch (e) {
    console.error(`[${new Date().toISOString()}] Error parsing JSON request body:`, e);
    return new Response(JSON.stringify({ error: "Invalid JSON payload" }), {
      status: 400,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }

  let supabaseAdmin: SupabaseClient;
  try {
    console.log(`[${new Date().toISOString()}] Initializing Supabase Admin client...`);
    // WICHTIG: Verwende Umgebungsvariablen für URL und Service Role Key
    const supabaseUrl = Deno.env.get("SUPABASE_URL");
    const supabaseServiceRoleKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

    if (!supabaseUrl || !supabaseServiceRoleKey) {
        console.error(`[${new Date().toISOString()}] Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY environment variables.`);
        throw new Error("Server configuration error: Missing Supabase credentials.");
    }

    supabaseAdmin = createClient(supabaseUrl, supabaseServiceRoleKey, {
        auth: { 
            autoRefreshToken: false, 
            persistSession: false 
        }
    });
    console.log(`[${new Date().toISOString()}] Supabase Admin client initialized.`);
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Failed to initialize Supabase Admin client:`, error);
    return new Response(JSON.stringify({ error: "Failed to initialize Supabase client" }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }

  try {
    console.log(`[${new Date().toISOString()}] Fetching SMTP settings for user: ${payload.smtpConfig.auth.user}`);
    const { data: smtpSettings, error: smtpError } = await supabaseAdmin
      .from('smtp_config') // Changed table name from smtp_settings to smtp_config
      .select('host, port, secure, user, pass')
      .eq('user', payload.smtpConfig.auth.user)
      .single();

    console.log(`[${new Date().toISOString()}] Fetched SMTP settings object:`, JSON.stringify(smtpSettings));

    if (smtpError || !smtpSettings) {
      console.error(`[${new Date().toISOString()}] Error fetching SMTP settings or not found for user ${payload.smtpConfig.auth.user}:`, smtpError);
      const errorMessage = smtpError?.code === 'PGRST116' 
          ? `No SMTP settings found for user ${payload.smtpConfig.auth.user}. Please configure them.` 
          : `Failed to fetch SMTP settings: ${smtpError?.message || 'Unknown error'}`;
      return new Response(JSON.stringify({ error: errorMessage }), {
        status: smtpError?.code === 'PGRST116' ? 404 : 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }
    console.log(`[${new Date().toISOString()}] SMTP settings fetched successfully for user: ${payload.smtpConfig.auth.user}`);
    
    // Validate SMTP settings
    if (!smtpSettings.host || !smtpSettings.port || !smtpSettings.user || !smtpSettings.pass) {
      console.error(`[${new Date().toISOString()}] Incomplete SMTP settings for user ${payload.smtpConfig.auth.user}.`);
      return new Response(JSON.stringify({ error: "Incomplete SMTP settings configured." }), {
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    // Generate HTML content (if not provided as text)
    let htmlContent: string | undefined = undefined;
    if (!payload.text) {
      // Simple HTML representation of the report
      htmlContent = render(
        h('div', null,
          h('h2', null, `Arbeitsrapport für ${payload.reportData.client} (${payload.reportData.month}/${payload.reportData.year})`),
          h('p', null, `Mitarbeiter: ${payload.reportData.employeeName}`),
          h('table', { border: "1" },
            h('thead', null,
              h('tr', null,
                h('th', null, 'Datum'),
                h('th', null, 'Arbeitsort'),
                h('th', null, 'Beschreibung'),
                h('th', null, 'Stunden')
              )
            ),
            h('tbody', null,
              payload.reportData.entries.map(entry =>
                h('tr', null,
                  h('td', null, entry.date),
                  h('td', null, entry.location || ''),
                  h('td', null, entry.description),
                  h('td', { style: 'text-align:right;' }, entry.hours.toFixed(2))
                )
              ),
              h('tr', null,
                h('td', { colSpan: 3, style:'text-align:right; font-weight:bold;' }, 'Gesamt:'),
                h('td', { style:'text-align:right; font-weight:bold;' }, payload.reportData.totalHours.toFixed(2))
              )
            )
          )
        )
      );
    }

    // Generate Attachment based on format
    let attachment: AttachmentData;
    if (payload.format === "excel") {
      attachment = await generateExcelAttachment(payload.reportData);
    } else if (payload.format === "pdf") {
      attachment = await generatePdfAttachment(payload.reportData);
    } else {
      // Basic CSV generation (example)
      let csvContent = "Datum,Arbeitsort,Beschreibung,Stunden
";
       payload.reportData.entries.forEach(e => {
           // Basic CSV escaping (replace quotes) - consider a proper library for complex cases
           const desc = e.description.replace(/"/g, '""');
           csvContent += `${e.date},${e.location || ""},"${desc}",${e.hours}
`;
       });
       csvContent += `
Gesamt,,,,${payload.reportData.totalHours}`;
       attachment = {
           filename: `Arbeitsrapport_${payload.reportData.client}_${payload.reportData.month}_${payload.reportData.year}.csv`,
           content: new TextEncoder().encode(csvContent), // Convert string to Uint8Array
           contentType: "text/csv",
       };
    }

    // Convert attachment content to Base64
    const base64Content = encode(attachment.content);

    // Prepare Payload for Vercel Function
    const vercelPayload = {
      smtpConfig: payload.smtpConfig, // Pass the user's SMTP config
      to: payload.to,
      subject: payload.subject,
      text: payload.text, // Pass optional text content
      html: htmlContent, // Pass generated HTML content
      attachments: [
        {
          filename: attachment.filename,
          content: base64Content, // Send Base64 encoded content
          contentType: attachment.contentType,
          encoding: 'base64' // Specify encoding for Vercel function
        },
      ],
    };

    // Define Vercel Function URL and Auth Token
    const vercelFunctionUrl = "https://vercel-smtp-sender.vercel.app/api/send";
    // Alternative using environment variable (RECOMMENDED):
    const authToken = Deno.env.get('VERCEL_SMTP_SENDER_TOKEN');
    if (!authToken) {
       console.error("Error: VERCEL_SMTP_SENDER_TOKEN environment variable not set in Supabase secrets.");
       return new Response(JSON.stringify({ error: "Server configuration error: Missing auth token." }), { status: 500, headers: { "Content-Type": "application/json" }});
    }

    // Call Vercel Function
    console.log(`[${new Date().toISOString()}] Calling Vercel function at ${vercelFunctionUrl}...`);
    const response = await fetch(vercelFunctionUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${authToken}`, // Use the secret token
        // Pass Supabase key if needed by Vercel func (optional, depends on Vercel func logic)
        // "apikey": Deno.env.get("SUPABASE_ANON_KEY") ?? "",
      },
      body: JSON.stringify(vercelPayload),
    });

    // Handle Vercel Function Response
    const responseBody = await response.json();

    if (!response.ok) {
      console.error("Error from Vercel function:", response.status, responseBody);
      // Forward the error from Vercel
      return new Response(JSON.stringify({ error: responseBody.error || "Vercel function failed", details: responseBody }), {
        status: response.status, // Use Vercel's status code
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*", // Be more specific in production
          "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
         },
      });
    }

    // Return Success Response
    console.log("Email sent successfully via Vercel function. Message ID:", responseBody.messageId);
    return new Response(JSON.stringify({ success: true, messageId: responseBody.messageId }), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*", // Be more specific in production
        "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
       },
    });

  } catch (error) {
    console.error(`[${new Date().toISOString()}] Unhandled error in function:`, error);
    // Log specific error details if possible
    const errorMessage = error instanceof Error ? error.message : "Internal Server Error";
    const errorStack = error instanceof Error ? error.stack : "No stack trace available";
    console.error(`[${new Date().toISOString()}] Error Message: ${errorMessage}`);
    console.error(`[${new Date().toISOString()}] Error Stack: ${errorStack}`);

    return new Response(JSON.stringify({ error: "Internal Server Error", details: errorMessage }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
});

console.log("Function initialized and waiting for requests.");
